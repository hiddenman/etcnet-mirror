#!/bin/bash

# FIXME
# move to another place
in_list()
{
	OLDIFS=$IFS
	IFS=" "
	for element in $1; do
		if [ "$element" = "`basename $2`" ]; then
			IFS=$OLDIFS
			return 0
		fi	
	done
	IFS=$OLDIFS
	return 1
}

iptables_chain_policy()
{
	eval "$IPTABLES -P $@" || print_error "$IPTABLES -P $@"
}

iptables_create_chain()
{
	eval "$IPTABLES -N $@" || print_error "$IPTABLES -N $@"
}

iptables_delete_chain()
{
	eval "$IPTABLES -X $@" || print_error "$IPTABLES -X $@"
}

iptables_flush_chain()
{
	eval "$IPTABLES -F $@" || print_error "$IPTABLES -F $@"
}

iptables_push_rule()
{
    case $1 in
	"-A"|"-I"|"-D")
	    eval "$IPTABLES $@" || print_error "$IPTABLES $@"
	;;
	*)
    	    case ${IPTABLES_RULE_EMBEDDING:APPEND} in
    		APPEND)
	    	    eval "$IPTABLES -A $@" || print_error "$IPTABLES -A $@"
		;;
		INSERT)
	    	    eval "$IPTABLES -I $@" || print_error "$IPTABLES -I $@"
		;;
		*)
		print_error "Unknown type of rule embedding $IPTABLES_RULE_EMBEDDING"
		;;
	    esac
	;;
    esac
}

iptables_pop_rule()
{
    case $1 in
	"-A")
	    shift
	    eval "$IPTABLES -D $@" || print_error "$IPTABLES -D $@"	    	    
	;;
	"-I")
	    PRE="$2"
		case $3 in
			[0-9]*)
				shift 3
			;;
			*)
				shift 2
			;;
		esac
	    eval "$IPTABLES -D $PRE $@" || print_error "$IPTABLES -D $PRE $@"
	;;	
	"-D")
	    shift
	    iptables_push_rule $@
	;;
	*)
        eval "$IPTABLES -D $@" || print_error "$IPTABLES -D $@"	    	        	
	;;
    esac
}

iptables_load_syntax()
{
	export iptables_syntax=
	[ -z "$1" ] || [ ! -f "$1" ] || [ ! -s "$1" ] && return 1
	export iptables_syntax=$(< "$1")
}

iptables_create_sed_rules()
{
    export iptables_sed_rules=
    [ $# -lt 1 -o -z "$1" ] && return 1
    replaces="$1"
    print_message "Loading iptables data"
    OLDIFS=$IFS
    IFS=":"
    while read search replace; do
        print_progress
        iptables_sed_rules=${iptables_sed_rules}"s/\(^\|[^-]\b\)$search\(\b[^-]\|$\)/\1$replace\2/g;"
    done < <(echo "$replaces"|egrep "^[^#]"|sed -e 's/\//\\\\\//g')
    IFS=$OLDIFS
    print_message
    export iptables_sed_rules
}

iptables_expand_string()
{
	[ -z "$1" ] && return 1
	if is_yes "$IPTABLES_HUMAN_SYNTAX"; then
		[ -z "$iptables_sed_rules" ] && print_error "Human syntax is enabled but no syntax file is loaded"
		rule=$(eval "echo $1"|sed  -e "$iptables_sed_rules;s/\ \ /\ /g;")
	else
		rule=$(eval "echo $1")
	fi
	echo "$rule"|egrep -q "^[^#]" && echo "$rule" || echo ""
}

iptables_preload()
{
	is_yes "$IPTABLES_HUMAN_SYNTAX" && [ -z "$iptables_syntax" ] && { 
		iptables_load_syntax ${IPTABLES_SYNTAX_DIR:=/etc/net/ifaces/default/fw/iptables}/syntax
		iptables_create_sed_rules "$iptables_syntax"
		}			
}

iptables_load_rules_from_file()
{
	if [ -f "$chain" ] && [ -s "$chain" ]; then
		print_message "Loading rules for chain `basename $chain` in table `basename $table`"
		rules=$(< "$chain")
		while read rule; do
				rule=`iptables_expand_string "$rule"`
				[ -z "$rule" ] || {
				    read FIRST SECOND REST < <(echo $rule)
    					case $FIRST in
					    "-A"|"-D")
        					iptables_push_rule $FIRST `basename $chain` -t `basename $table` $SECOND $REST
						;;
					    "-I")
						case $SECOND in
						    [0-9]*)
	        					iptables_push_rule $FIRST `basename $chain` $SECOND -t `basename $table` $REST
						    ;;
						    *)
	        					iptables_push_rule $FIRST `basename $chain` -t `basename $table` $SECOND $REST
						    ;;
						esac
						;;					    
					    *)
        					iptables_push_rule `basename $chain` -t `basename $table` $FIRST $SECOND $REST
					    ;;
						esac
				}
				print_progress
		done < <(echo "$rules"|egrep "^[^#]")
		print_message
	fi
}

iptables_flush_rules_from_file()
{
	if [ -f "$chain" ] && [ -s "$chain" ]; then
		print_message "Flushing rules for chain `basename $chain` in table `basename $table`"
		# Flush rules only when stop networking
		if [ "$NAME" != "default" ]; then
			rules=$(tac "$chain")
			while read rule; do
				rule=`iptables_expand_string "$rule"`
				[ -z "$rule" ] || {
				    read  FIRST SECOND REST < <(echo $rule)
					case $FIRST in
					    "-A"|"-D")
        					iptables_pop_rule $FIRST `basename $chain` -t `basename $table` $SECOND $REST
						;;
					    "-I")
						case $SECOND in
						    [0-9]*)
	        					iptables_pop_rule $FIRST `basename $chain` $SECOND -t `basename $table` $REST
						    ;;
						    *)
	        					iptables_pop_rule $FIRST `basename $chain` -t `basename $table` $SECOND $REST
						    ;;
						esac
						;;					    
					    *)
        					iptables_pop_rule `basename $chain` -t `basename $table` $FIRST $SECOND $REST
					    ;;
						esac
				}				
				print_progress
			done < <(echo "$rules"|egrep "^[^#]")
			print_message
		else
			iptables_flush_chain `basename $chain` -t `basename $table`
		fi
	fi
}


iptables_start()
{
	[ -z "$1" ] && return 1	
	NAME="$1"
	print_message "Starting iptables for $NAME"
	# Set defaut policy
	if [ "$NAME" = "default" ]; then
		[ -z "$IPTABLES_INPUT_POLICY" ] || {
			print_message "Set $IPTABLES_INPUT_POLICY policy for INPUT chain"
			iptables_chain_policy INPUT "$IPTABLES_INPUT_POLICY"
		}
		[ -z "$IPTABLES_FORWARD_POLICY" ] || {
			print_message "Set $IPTABLES_FORWARD_POLICY policy for FORWARD chain"
			iptables_chain_policy FORWARD "$IPTABLES_FORWARD_POLICY"
		}
		[ -z "$IPTABLES_OUTPUT_POLICY" ] || {
			print_message "Set $IPTABLES_OUTPUT_POLICY policy for OUTPUT chain"
			iptables_chain_policy OUTPUT "$IPTABLES_OUTPUT_POLICY"
		}
	fi
	cd "$MYIFACEDIR/fw/$FW_TYPE"
	# Load modules
	if [ -f "modules" ] && [ -s "modules" ]; then
		while read module; do
			print_message "Loading module $module"
			$MODPROBE "$module" || print_error "Can't load module $module"
		done < <(egrep "^[^#]" modules)
	fi
	# Create user chains
	for table in *; do
		[ "`basename $table`" = "loadorder" ] && continue
		[ ! -d "$table" ] && continue
		for chain in "$table"/*; do
			[ "`basename $chain`" = "loadorder" ] && continue
			if [ -f "$chain" ] && [ -s "$chain" ]; then
				if ! in_list "$IPTABLES_SYSTEM_CHAINS"  "$chain"; then
					print_message "Creating chain `basename $chain` in table `basename $table`"
					iptables_create_chain `basename $chain` -t `basename $table`
				fi
			fi
		done
	done

	# FIXME  Double code
	# Load rules after creating _all_ chains
	if [ -f "loadorder" ] && [ -s "loadorder" ]; then
		while read table; do
			[ ! -d "$table" ] && continue
			if [ -f "$table/loadorder" ] && [ -s "$table/loadorder" ]; then
				while read chain; do
					chain="$table/$chain"
					iptables_load_rules_from_file
				done < <(egrep "^[^#]" "$table/loadorder")
			else
				for chain in "$table"/*; do
					iptables_load_rules_from_file
				done
			fi
		done < <(egrep "^[^#]" loadorder)
	else
		for table in *; do
			[ "`basename $table`" = "loadorder" ] && continue
			[ ! -d "$table" ] && continue
			if [ -f "$table/loadorder" ] && [ -s "$table/loadorder" ]; then
				while read chain; do
					chain="$table/$chain"
					iptables_load_rules_from_file
				done < <(egrep "^[^#]" "$table/loadorder")
			else
				for chain in "$table"/*; do
					iptables_load_rules_from_file
				done
			fi
		done
	fi
}

iptables_stop()
{
	[ -z "$1" ] && return 1	
	NAME="$1"
	print_message "Stopping iptables for $NAME"
	cd "$MYIFACEDIR/fw/$FW_TYPE"

	# FIXME  Double code
	# Flush rules
	if [ -f "loadorder" ] && [ -s "loadorder" ]; then
		while read table; do
			[ ! -d "$table" ] && continue
			if [ -f "$table/loadorder" ] && [ -s "$table/loadorder" ]; then
				while read chain; do
					chain="$table/$chain"
					iptables_flush_rules_from_file
				done < <(tac "$table/loadorder"|egrep "^[^#]")
			else
				for chain in "$table"/*; do
					iptables_flush_rules_from_file
				done
			fi
		done < <(tac loadorder|egrep "^[^#]")
	else
		for table in *; do
			[ "`basename $table`" = "loadorder" ] && continue
			[ ! -d "$table" ] && continue
			if [ -f "$table/loadorder" ] && [ -s "$table/loadorder" ]; then
				chainsorder=$(tac "$table/loadorder")
				while read chain; do
					chain="$table/$chain"
					iptables_flush_rules_from_file
				done < <(tac "$table/loadorder"|egrep "^[^#]")
			else
				for chain in "$table"/*; do
					iptables_flush_rules_from_file
				done
			fi
		done
	fi

	# Delete user chains
	for table in *; do
		[ "`basename $table`" = "loadorder" ] && continue
		[ ! -d "$table" ] && continue
		for chain in "$table"/*; do
			[ "`basename $chain`" = "loadorder" ] && continue
			if [ -f "$chain" ] && [ -s "$chain" ] ; then
				if ! in_list "$IPTABLES_SYSTEM_CHAINS"  "$chain"; then
					print_message "Deleting chain `basename $chain` from table `basename $table`"
					iptables_delete_chain `basename $chain` -t `basename $table`
				fi
			fi
		done
	done

	# Unload modules
	if [ -f "modules" ] && [ -s "modules" ]; then
		while read module; do
			print_message "Unloading module $module"
			$MODPROBE -r "$module" || print_error "Can't unload module $module"
		done < <(tac modules|egrep "^[^#]")
	fi
	# Set ACCEPT policy
	if [ "$NAME" = "default" ]; then
		print_message "Set ACCEPT policy for INPUT chain"
		iptables_chain_policy INPUT ACCEPT
		print_message "Set ACCEPT policy for FORWARD chain"
		iptables_chain_policy FORWARD ACCEPT
		print_message "Set ACCEPT policy for OUTPUT chain"
		iptables_chain_policy OUTPUT ACCEPT
	fi
}
