#!/bin/bash
# Firewall script
#

# Known issues:
# 1. When interface is 'all' we can't guess correct interfaces processing order
#    like etcnet does so process it by bash sort order
# 2. Guessing may not work correct
# 3. Что будет, если указано: efw rule "some rule"? оно же попадет под полный
# разбор и заглючит, если $#==4

# default values
NAME=default
TABLE=filter
CHAIN=
MYIFACEDIR=
TABLES="mangle filter nat"
ACTIONS="start stop restart load unload reload flush show count rule"

usage()
{
	echo "Usage: $0 [iface] [table] [chain] <action> [iptables rule]" >&2
	echo ""
	echo "iface   - 'default' (by default) or real interface name"
	echo "table   - 'mangle', 'filter' (by default), 'nat'"
	echo "chain   -  system or user defined chain name (case sensitive!)"
	echo "action  - 'start','stop','restart','load','unload','reload','flush','show','count','rule'"
	echo ""
	echo "start   - process all tables and chains for given interface (even when chain or table is defined)"
	echo "stop    - process all tables and chains for given interface (even when chain or table is defined)"
	echo "restart - equivalent to stop then start"	  
	echo "load    - load rules for given interface, table and chain"
	echo "unload  - unload rules for given interface, table and chain"
	echo "reload  - equivalent to unload then load"	  
	echo "flush   - flush rules for given interface, table and chain"
	echo "show    - list rules for given interface, table and chain"
	echo "count   - show counters for given table and chains"
	echo "rule    - parse rule and pass it to iptables"
	echo ""
	exit 1
}



guess_options()
{
	# Four options. Get interface name and shift
	[ $# -ge 4 ] && 
	{
		NAME="$1"
		[ "$NAME" != 'default' ] && 
		{
			[ -d $IFACEDIR/$NAME@$NETHOST ] && MYIFACEDIR=$IFACEDIR/$NAME@$NETHOST || MYIFACEDIR=$IFACEDIR/$NAME
			[ -d "$MYIFACEDIR" ] || {
				print_error "interface configuration directory '$MYIFACEDIR' not found"
				exit 1
			}
		}
		egrep -q "([^-]\b|^)$2(\b[^-]|$)" < <(echo "$TABLES") && TABLE="$2" ||
		{
			print_error "Unknown firewall table $2"
			exit 1
		}
		CHAIN="$3"
		egrep -q "([^-]\b|^)$4(\b[^-]|$)" < <(echo "$ACTIONS") && ACTION="$4" ||
		{
			print_error "Unknown firewall action $4"
			exit 1
		}
		return
	}

	# Three options. Guess first and shift
	[ $# -eq 3 ] && 
	{
			[ "$1" != 'default' ] && 
			{
				# May be it's and interface name
				[ -d $IFACEDIR/$1@$NETHOST ] && MYIFACEDIR=$IFACEDIR/$1@$NETHOST || MYIFACEDIR=$IFACEDIR/$1
				[ -d "$MYIFACEDIR" ] &&
				{
					# Yes, it's an interface name
					NAME="$1"
					egrep -q "([^-]\b|^)$2(\b[^-]|$)" < <(echo "$TABLES") && TABLE="$2" || CHAIN="$2"
				} ||
				{
					# No, it's not an interface name
					egrep -q "([^-]\b|^)$1(\b[^-]|$)" < <(echo "$TABLES") && 
					{
						TABLE="$1"
						CHAIN="$2"
					} || 
					{
						print_error "Unknown firewall table $1"
						exit 1
					}
				}
			} ||
			{
				# Yes, it's an interface name
				NAME="$1"
				egrep -q "([^-]\b|^)$2(\b[^-]|$)" < <(echo "$TABLES") && TABLE="$2" || CHAIN="$2"
			}
			shift 2
	}

	# Two options. Guest first and shift
	[ $# -eq 2 ] && 
	{
		[ "$1" != 'default' ] && 
			{
				# May be it's and interface name
				[ -d $IFACEDIR/$1@$NETHOST ] && MYIFACEDIR=$IFACEDIR/$1@$NETHOST || MYIFACEDIR=$IFACEDIR/$1
				[ -d "$MYIFACEDIR" ] &&
				{
					# Yes, it's an interface name
					NAME="$1"
				} ||
				{
					# No
					egrep -q "([^-]\b|^)$1(\b[^-]|$)" < <(echo "$TABLES") && TABLE="$1" || CHAIN="$1"
				}
			} ||
			{
				# Yes, it's an interface name
				NAME="$1"
			}
			shift
	
		}
	# One option
	[ $# -eq 1 ] &&
	{
		egrep -q "([^-]\b|^)$1(\b[^-]|$)" < <(echo "$ACTIONS") && ACTION=$1 ||
		{
			print_error "Unknown firewall action $1"
			exit 1
		}
	}
}

iptables_local_start()
{
	is_yes "$IPTABLES_HUMAN_SYNTAX" && [ -z "$iptables_syntax" ] && { 
		iptables_load_syntax `profiled_filename /etc/net/ifaces/default/fw/iptables/syntax`
		iptables_create_sed_rules "$iptables_syntax"
	}			
	is_yes "$IPTABLES_HUMAN_SYNTAX" && [ -z "$iptables_sed_rules" ] && iptables_create_sed_rules "$iptables_syntax"
	iptables_start "$NAME"
}

iptables_local_stop()
{
	is_yes "$IPTABLES_HUMAN_SYNTAX" && [ -z "$iptables_syntax" ] && { 
		iptables_load_syntax `profiled_filename /etc/net/ifaces/default/fw/iptables/syntax`
		iptables_create_sed_rules "$iptables_syntax"
	}			
	is_yes "$IPTABLES_HUMAN_SYNTAX" && [ -z "$iptables_sed_rules" ] && iptables_create_sed_rules "$iptables_syntax"
	iptables_stop "$NAME"
}

. ${SCRIPTDIR:=/etc/net/scripts}/functions
pickup_defaults
. ${SCRIPTDIR:=/etc/net/scripts}/functions-fw

[ -z "$NETPROFILE" ] && init_netprofile

[ -z "$CONFIG_FW" ] && {
	SourceIfNotEmpty `profiled_filename /etc/net/ifaces/default/options`
	SourceIfNotEmpty `profiled_filename /etc/net/ifaces/default/fw/options`
}

if  ! is_yes "$CONFIG_FW";  then
	print_message "Firewall is disabled"
	exit 1
fi

[ $# -lt 1 ] && usage || guess_options $@

echo "interface is $NAME"
echo "table is $TABLE"
echo "chain is $CHAIN"
echo "action is $ACTION"
echo ""

SourceIfNotEmpty "$MYIFACEDIR/fw/options"

case "$FW_TYPE" in
	iptables)
	 	[ -d "$MYIFACEDIR/fw/$FW_TYPE" ] || exit 0
		# Load own interface syntax if exists
		[ "$NAME" != "default" ] && is_yes "$IPTABLES_HUMAN_SYNTAX" && {
			[ -f "$MYIFACEDIR/fw/$FW_TYPE/syntax" ] && [ -s "$MYIFACEDIR/fw/$FW_TYPE/syntax" ] && {
				IPTABLES_SYNTAX_DIR="$MYIFACEDIR/fw/$FW_TYPE"
				export iptables_syntax=
				export iptables_sed_rules=
			}
		}
		case "$ACTION" in
			start)
				iptables_local_start
				;;
			stop)
				iptables_local_stop
				;;
			restart)
				iptables_local_stop
				iptables_local_start
				;;
			load)
				iptables_local_load
				;;
			unload)
				iptables_local_unload
				;;
			reload)
				iptables_local_load
				iptables_local_unload
				;;
			flush)
				iptables_local_flush
				;;
			show)
				iptables_local_show
				;;
			count)
				iptables_local_count
				;;
			rule)
				iptables_local_rule
				;;
			*)
				usage
				;;
#start stop restart load unload reload flush show count rule				
		esac
		;;
	*)
		echo "Firewall type $FW_TYPE isn't supported"
esac

