#!/bin/bash

. /etc/init.d/functions
SourceIfNotEmpty $SCRIPTDIR/functions
pickup_options

try_static()
{
	[ -s `profiled_filename $MYIFACEDIR/ipv4address` ] && \
	egrep -v '^$|^#' `profiled_filename $MYIFACEDIR/ipv4address` | \
	xargs --max-lines=1 $IP -4 address add dev $NAME
}

try_dhcp()
{
	$DHCP_CLIENT -d -t $DHCP_TIMEOUT $NAME >/dev/null
	return $?
}

try_zcip()
{
	$ZCIP_CLIENT -s -i $NAME
	return $?
}

config_routes_rules()
{
	# setup routes
	[ -s `profiled_filename $MYIFACEDIR/ipv4route` ] && egrep -v '^$|^#' `profiled_filename $MYIFACEDIR/ipv4route` | \
	while read FIRST REST; do
	# If there is no operation, substitute default, otherwise keep.
		case "$FIRST" in
			add|del|change|append|replace)
				$IP -4 route $FIRST $REST
			;;
			*)
				$IP -4 route $DEFAULT_IPV4ROUTE_CMD $FIRST $REST
			;;
		esac
	done

	# Setup rules only after routes are Ok, so that route tables are
	# already populated when rule starts routing traffic to them.
	# Note that we don't have 'add' here.
	# As for now, you will have to place both 'del' and 'add'
	# records for the same rule to prevent multiple records in
	# kernel rule table.
	[ -s `profiled_filename $MYIFACEDIR/ipv4rule` ] && egrep -v '^$|^#' `profiled_filename $MYIFACEDIR/ipv4rule` | \
	while read FIRST REST; do
	# If there is no operation, substitute default, otherwise keep.
		case "$FIRST" in
			add|del)
				$IP -4 rule $FIRST $REST
			;;
			*)
				$IP -4 rule $DEFAULT_IPV4RULE_CMD $FIRST $REST
			;;
		esac
	done
}

if iface_is_up $NAME; then
	case "$BOOTPROTO" in
		static)
			try_static && config_routes_rules
			;;
		dhcp)
			try_dhcp && config_routes_rules
			;;
		zcip)
			try_zcip && config_routes_rules
			;;
		dhcp-static)
			try_dhcp || try_static && config_routes_rules
			;;
		dhcp-zcip)
			try_dhcp || try_zcip && config_routes_rules
			;;
		dhcp-zcip-static)
			try_dhcp || try_zcip || try_static && config_routes_rules
			;;
		*)
			print_error "unknown BOOTPROTO '$BOOTPROTO'"
			;;
	esac
fi
