#!/bin/bash

usage()
{
	echo '/etc/net IPv4 handler'
	echo "Usage: $0 <interface> <start|stop>" >&2
	exit 1
}

[ $# -eq 2 ] || usage
NAME=$1
ACTION=$2
pickup_defaults
pickup_options

# operation\first word | add X | del X | Y X
#----------------------+-------+-------+------
# add                  | add X | del X | add X
#----------------------+-------+-------+------
# del                  | del X | del X | del X
#----------------------+-------+-------+------
process_ipv4rules()
{
	local OP=${1:?missing 1st arg to $FUNCNAME}
	SRCFILE=`profiled_filename $MYIFACEDIR/ipv4rule`
	[ -s "$SRCFILE" ] && $DENOISE "$SRCFILE" | \
	while read FIRST REST; do
		case "$FIRST" in
			add)
				[ $OP = "del" ] && FIRST=del
			;;
			del)
				# should we restore deleted rules on iface shutdown?
				# [ $OP = "del" ] && FIRST=add
			;;
			*)
				FIRST="$OP $FIRST"
			;;
		esac
		$IP -4 rule $FIRST $REST
		print_progress
	done
}

case $ACTION in
	start)
		try_static()
		{
			local REALFILE=`profiled_filename $MYIFACEDIR/ipv4address`
			if [ -s $REALFILE ]; then
				local ADDRESSLINE
				$DENOISE $REALFILE | while read ADDRESSLINE; do
					is_yes "$AUTO_BROADCAST" && [ "$ADDRESSLINE" = "${ADDRESSLINE/broadcast/}" ] && \
						ADDRESSLINE="$ADDRESSLINE broadcast +"
					$IP -4 address add dev $NAME $ADDRESSLINE && print_progress
				done
			fi
			return 0
		}

		try_dhcp()
		{
			[ -x "$DHCP_CLIENT" ] || {
				print_error "$DHCP_CLIENT does not exist or is not executable. Try installing dhcpcd RPM."
				return 1
			}
			if need_detection; then
				if check_eth_link $NAME; then
					print_progress
				else
					print_nack
					return 1
				fi
			fi
			if [ -n "$DHCP_HOSTNAME" ]; then
				case "$DHCP_HOSTNAME" in
					AUTO)
						DHCP_ARGS="$DHCP_ARGS -H"
					;;
					localhost)
						[ -n "$HOSTNAME" -a "$HOSTNAME" != "localhost" -a "$HOSTNAME" != "localhost.localdomain" ] && DHCP_ARGS="$DHCP_ARGS -h $HOSTNAME"
					;;
					*)
						DHCP_ARGS="$DHCP_ARGS -h $DHCP_HOSTNAME"
					;;
				esac
			fi
			$DHCP_CLIENT $DHCP_ARGS -d -t $DHCP_TIMEOUT $NAME >/dev/null
			local RET=$?
			# dhcpcd sets iface down on failure, breaking dhcp-* BOOTPROTOs
			if [ "$RET" != "0" ]; then
				print_nack
				! is_yes $KEEP_DOWN && $IP link set dev $NAME up
			else
				print_progress
			fi
			return $RET
		}

		try_ipv4ll()
		{
			[ -x "$ZCIP_CLIENT" ] || {
				print_error "$ZCIP_CLIENT does not exist or is not executable. Try installing zcip RPM."
				return 1
			}
			if need_detection; then
				if check_eth_link $NAME; then
					print_progress
				else
					print_nack
					return 1
				fi
			fi
			$ZCIP_CLIENT -s -i $NAME
			local RET=$?
			if [ "$RET" != "0" ]; then
				print_nack
			else
				print_progress
			fi
			return $RET
		}

		config_ipv4_routes_rules()
		{
			# setup routes
			local SRCFILE=`profiled_filename $MYIFACEDIR/ipv4route`
			local SUFFIX
			[ -s "$SRCFILE" ] && $DENOISE "$SRCFILE" | \
			while read FIRST REST; do
				# If 'dev' is not specified, add current dev.
				SUFFIX=''
				echo "$FIRST $REST" | egrep -q '[[:space:]]dev[[:space:]]' || SUFFIX="dev $NAME"
				# If operation is not specified, use 'append'.
				case "$FIRST" in
					add|del|change|append|replace)
						$IP -4 route $FIRST $REST $SUFFIX
					;;
					*)
						$IP -4 route append $FIRST $REST $SUFFIX
					;;
				esac
				print_progress
			done

			# Setup rules only after routes are Ok, so that route tables are
			# already populated when rule starts routing traffic to them.
			process_ipv4rules add
		}

		is_yes $DONT_FLUSH || {
			$IP -4 address flush dev $NAME >/dev/null 2>&1
			print_progress
		}
		if iface_is_up $NAME; then
			case "$BOOTPROTO" in
				static)
					try_static && config_ipv4_routes_rules
					;;
				dhcp)
					try_dhcp && config_ipv4_routes_rules
					;;
				ipv4ll)
					try_ipv4ll && config_ipv4_routes_rules
					;;
				dhcp-static)
					try_dhcp || try_static && config_ipv4_routes_rules
					;;
				dhcp-ipv4ll)
					try_dhcp || try_ipv4ll && config_ipv4_routes_rules
					;;
				dhcp-ipv4ll-static)
					try_dhcp || try_ipv4ll || try_static && config_ipv4_routes_rules
					;;
				*)
					print_error "unknown BOOTPROTO '$BOOTPROTO'"
					;;
			esac
		fi
	;;
	#------------------------------------------------------ 'start' case ends
	stop)
		process_ipv4rules del
		is_yes "$DONT_FLUSH" || $IP -4 address flush dev $NAME >/dev/null 2>&1
	;;
	#------------------------------------------------------ 'stop' case ends
	*)
		print_error "Illegal argument to $0: '$ACTION'"
	;;
esac
