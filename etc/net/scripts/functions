#!/bin/bash

. /etc/net/options
CUTSP="cut --delimiter=' '"
DENOISE="egrep '^[^#]'"

# Stolen from /etc/init.d/functions and improved.
is_yes()
{
	local TESTVAL=${1:?missing 1st arg to $FUNCNAME}
	case "$TESTVAL" in
		[Yy][Ee][Ss]|[Tt][Rr][Uu][Ee]|[Oo][Nn]|[Yy]|1)
			# true returns zero
			return 0
		;;
		*)
			# false returns one
			return 1
		;;
	esac
}

is_no()
{
	local TESTVAL=${1:?missing 1st arg to $FUNCNAME}
	case "$TESTVAL" in
		[Nn][Oo]|[Ff][Aa][Ll][Ss][Ee]|[Oo][Ff][Ff]|[Nn]|0)
			# true returns zero
			return 0
			;;
		*)
			# false returns one
			return 1
		;;
	esac
}

SourceIfNotEmpty()
{
	local f
	f="$1"
	shift
	[ -s "$f" ] && . "$f" "$@"
}

ExecIfExecutable()
{
	local f
	f="$1"
	shift
	[ -x "$f" ] && "$f" "$@"
}

supported_type()
{
	local TYPE=${1:?missing 1st arg to $FUNCNAME}
	[ -x $SCRIPTDIR/create-$TYPE -o -x $SCRIPTDIR/destroy-$TYPE ] && return 0
	return 1
}

# try to translate iface name into corresponding type
name2type()
{
	local NAME=${1:?missing 1st arg to $FUNCNAME}
	local CAND=${NAME//[0-9]*/}
	supported_type $CAND && echo $CAND
}

# read options hierarchy
pickup_options()
{
	# to determine iface type we must read it's config, but
	# we should read global config and type config first.
	# A workaround here.
	SourceIfNotEmpty `profiled_filename $MYIFACEDIR/options`
	is_yes "$DISABLED" && return
	[ -z "$TYPE" ] && TYPE=`name2type $NAME`
	[ -z "$TYPE" ] && {
		print_error "No TYPE is specified for iface '$NAME' and can't guess automatically. Please fix."
		return 1
	}
	if ! supported_type $TYPE; then
		print_error "iface type '$TYPE' is not supported"
	fi
	# source default options
	SourceIfNotEmpty `profiled_filename $IFACEDIR/default/options`
	# then source default options for our iface type
	SourceIfNotEmpty `profiled_filename $IFACEDIR/default/options-$TYPE`
	# and finally source iface options
	SourceIfNotEmpty `profiled_filename $MYIFACEDIR/options`
	# Load type-specific functions
	SourceIfNotEmpty $SCRIPTDIR/functions-$TYPE
}

print_error()
{
	echo "ERROR: $0: $@" > /dev/stderr
	# don't hang if logger hangs
	logger -p daemon.info -t "ERROR: $0: $@" &
}

# Don't display progress if not verbose.
if is_yes "$VERBOSE"; then
	print_message()
	{
		echo "$@"
		return 0
	}

	print_progress()
	{
		local SYMBOL=${1:-.}
		is_yes "$PROGRESS" && print_message -n "$SYMBOL"
		return 0
	}

	print_nack()
	{
		local SYMBOL=${1:-!}
		is_yes "$PROGRESS" && print_message -n "$SYMBOL"
		return 0
	}
else
	print_message() { return 0; }
	print_progress() { return 0; }
	print_nack() { return 0; }
fi

iface_is_up()
{
	local NAME=${1:?missing 1st argument to $FUNCNAME}
	$IP -o link show dev $NAME 2>/dev/null | $CUTSP -f3 | grep -qs '[<,]UP[,>]'
	return $?
}

try_rmmod()
{
	local MODNAME=${1:?missing 1st argument to $FUNCNAME}
	# Note: usage counter is treated in a different way by 2.6 kernels.
	# This may cause bugs :(
	$LSMOD | egrep -qs "^$MODNAME +[0-9]+ +0 " && rmmod $MODNAME
}

# Look if iface name will change after ifrename call.
get_mapped_ifname()
{
	local OLDNAME=${1:?missing 1st argument to $FUNCNAME}
	local PROF_IFTAB=`profiled_filename $IFTAB`
	if [ -s "$PROF_IFTAB" ]; then
		[ -x $IFRENAME ] || {
			print_error "$IFRENAME is unavailable, but $PROF_IFTAB exists"
			exit 1
		}
		NEW_NAME=`$IFRENAME -c $PROF_IFTAB -i $OLDNAME -D 2>/dev/null | head -1 | $CUTSP -f7 | sed 's/.$//'`
		[ $? = 0 -a -n "$NEW_NAME" ] && echo $NEW_NAME
	fi
}

profiled_filename()
{
	local BASE=${1:?missing 1st arg to $FUNCNAME}
	local CAND=$BASE${PROFILE:+#$PROFILE}
	[ -e $CAND ] && echo $CAND || echo $BASE
}

# This function updates current config file namespace, consisting of
# profile name and host name. Profile name can be overriden, but host
# name can't be.
# Should be called init_netprofile()
init_profile()
{
	if [ -n "$1" ]; then
		PROFILE="$1"
	elif [ -n "$MYIFACEDIR" -a -s "$MYIFACEDIR/selectprofile" -a -x "$MYIFACEDIR/selectprofile" ]; then
		PROFILE=`$MYIFACEDIR/selectprofile $0 | head -1 | $CUTSP -f1`
	elif [ -z "$PROFILE" ]; then
		if [ -s "$PROFILE_FILE" -a -r "$PROFILE_FILE" ]; then
			PROFILE=`$DENOISE -m 1 "$PROFILE_FILE" | $CUTSP -f1`
		elif [ -r "$PROC_CMDLINE" ]; then
			# try to fetch profile name from kernel options
			PROFILE=`cat "$PROC_CMDLINE" | sed 's/  / /g' | \
			sed 's/ /\n/g' | egrep '^netprof=' | cut --delimiter='=' --fields=2`
		fi
	fi
	return 0
}

# Network hostname init. Should be called by network.init during startup.
init_nethost()
{
	if [ -n "$1" ]; then
		NETHOST="$1"
	elif grep "^$HOSTNAME " $HOSTTAB; then
		NETHOST=`$DENOISE $HOSTTAB | grep -m 1 "^$HOSTNAME " | CUTSP -f2`
	else
		NETHOST=$HOSTNAME
	fi
	return 0
}

# iterator
foreach_child ()
{
	local WHAT=${1:?missing 1st argument to $FUNCNAME}
	local CHILDREN=`$SCRIPTDIR/childfinder $NAME`
	local ret=0
	for child in $CHILDREN; do
		$SCRIPTDIR/$WHAT $child || ret=$((ret+1))
	done
	return $ret
}

# get down all dependant ifaces
ifdown_children ()
{
	foreach_child ifdown
}

# same for ifdown
ifup_children ()
{
	foreach_child ifup
}

# check if parent iface(s) (REQUIRES=) is up and ifup if needed
ifup_parents ()
{
	local parent ret=0
	for parent in $REQUIRES; do
		if ! iface_is_up $parent; then
			$SCRIPTDIR/ifup $parent || {
				ret=$?
				break
			}
		fi
	done
	return $ret
}

ifdown_parents ()
{
	local parent ret=0
	for parent in $REQUIRES; do
		if iface_is_up $parent; then
			$SCRIPTDIR/ifdown $parent || {
				ret=$?
				break
			}
		fi
	done
	return $ret
}

iface_exists ()
{
	local NAME=${1:?missing 1st argument to $FUNCNAME}
	$IP li sh dev $NAME >/dev/null 2>&1
	return $?
}

seen_iface ()
{
	local needle=${1:?missing 1st arg to $FUNCNAME}
	for cand in $SEEN_IFACES; do
		[ "$cand" = "$needle" ] && return 0
	done
	return 1
}

add_seen_iface ()
{
	local newname=${1:?missing 1st arg to $FUNCNAME}
	if [ -z "$SEEN_IFACES" ]; then
		SEEN_IFACES=$newname
	else
		SEEN_IFACES="$SEEN_IFACES $newname"
	fi
}

# Universal configuration processor. Automatically does profiling,
# comments filtering and progress reporting.
xargise_file()
{
	local BASEFILE="${1:?missing 1st arg to $FUNCNAME}"
	local PROCESSOR="${2:?missing 2nd arg to $FUNCNAME}"
	local REALFILE=`profiled_filename $BASEFILE`
	if [ -s $REALFILE ]; then
		$DENOISE $REALFILE | xargs --max-lines=1 $PROCESSOR && print_progress
	fi
	return 0
}
