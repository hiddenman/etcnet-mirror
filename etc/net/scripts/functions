#!/bin/sh

. /etc/init.d/functions
# defaults
SourceIfNotEmpty /etc/net/options

supported_type()
{
	local TYPE=${1:?missing 1st arg to $FUNCNAME}
	[ -x $SCRIPTDIR/create-$TYPE -o -x $SCRIPTDIR/destroy-$TYPE ] && return 0
	return 1
}

# translate iface name into corresponding type
name2type()
{
	local NAME=${1:?missing 1st arg to $FUNCNAME}
	local CAND=`echo "$NAME" | sed "s/[0-9]*$//"`
	supported_type $CAND && echo $CAND
}

type2group()
{
	local TYPE=${1:?missing 1st arg to $FUNCNAME}
	case "$TYPE" in
		lo|dummy)
			echo '0'
		;;
		eth|plip)
			echo '1'
		;;
		vlan|bond)
			echo '2'
		;;
		iptun|ipsectun|eql)
			echo '3'
		;;
		ppp|ippp|pptp)
			echo '4'
		;;
	esac
}

# read options hierarchy
pickup_options()
{
	# to determine iface type we must read it's config, but
	# we should read global config and type config first.
	# A workaround here.
	SourceIfNotEmpty `profiled_filename $MYIFACEDIR/options`
	is_yes "$DISABLED" && return
	[ -z "$TYPE" ] && TYPE=`name2type $NAME`
	[ -z "$TYPE" ] && {
		print_error "No TYPE is specified for iface '$NAME' and can't guess automatically. Please fix."
		return 1
	}
	if ! supported_type $TYPE; then
		print_error "iface type '$TYPE' is not supported"
	fi
	# source default options
	SourceIfNotEmpty `profiled_filename $IFACEDIR/default/options`
	# then source default options for our iface type
	SourceIfNotEmpty `profiled_filename $IFACEDIR/default/options-$TYPE`
	# and finally source iface options
	SourceIfNotEmpty `profiled_filename $MYIFACEDIR/options`
}

print_error()
{
	echo "ERROR: $0: $@"
	logger -p daemon.info -t "ERROR: $0: $@"
}

# get VLAN iface name by host iface and VLAN ID
get_vlan_ifname()
{
	local HOSTIFACE=${1:?missing 1st arg to $FUNCNAME}
	local VID=${2:?missing 2nd arg to $FUNCNAME}
	grep "|\ *$VID\ *|\ *$HOSTIFACE" /proc/net/vlan/config | awk '{print $1}'
}

# create VLAN iface <parent iface> <VLAN ID> [name]
setup_vlan_iface()
{
	local VCONFIG=${VCONFIG:=$DEFAULT_VCONFIG}
	local NAMETYPE=${NAMETYPE:=$DEFAULT_VLAN_NAMETYPE}
	[ -x "$VCONFIG" ] || {
		print_error "$VCONFIG does not exist or is not executable. Try installing vlan-utils24 RPM."
		exit 2
	}
	$MODPROBE 8021q || {
		print_error "8021q kernel module not found"
		exit 2
	}
	local HOST_IFACE=${1:?missing 1st arg to $FUNCNAME}
	local VID=${2:?missing 2nd arg to $FUNCNAME}
	local NAME=$3
	local ADDRESS=$4
	$VCONFIG set_name_type $NAMETYPE >/dev/null 2>&1
	$VCONFIG add $HOST_IFACE $VID >/dev/null 2>&1
	local REALNAME=`get_vlan_ifname $HOST_IFACE $VID`
	if [ -z "$NAME" -o "$NAME" = "AUTO" ]; then
		NAME=$REALNAME
	else
		$IP link set $REALNAME name $NAME
	fi
	[ -n "$ADDRESS" ] && $IP address add $ADDRESS dev $NAME
}

shutdown_vlan_iface()
{
	local VCONFIG=${VCONFIG:=$DEFAULT_VCONFIG}
	[ -x "$VCONFIG" ] || {
		print_error "$VCONFIG does not exist or is not executable. Try installing vlan-utils24 RPM."
		exit 1
	}
	local HOST_IFACE=${1:?missing 1st arg to $FUNCNAME}
	local VID=${2:?missing 2nd arg to $FUNCNAME}
	local NAME=`get_vlan_ifname $HOST_IFACE $VID`
	$IP address flush dev $NAME >/dev/null 2>&1
	$VCONFIG rem $NAME >/dev/null 2>&1
}

start_vlantab()
{
	echo -n "Processing $VLANTAB: "
	[ -s `profiled_filename $VLANTAB` ] || {
		echo empty.
		return
	}
	local HOST_IFACE CHILD_VID CHILD_NAME
	SourceIfNotEmpty `profiled_filename $IFACEDIR/default/options-vlan`
	egrep -v '^$|^#' $VLANTAB | while read HOST_IFACE CHILD_VID CHILD_NAME; do
		iface_is_up "$HOST_IFACE" && setup_vlan_iface $HOST_IFACE $CHILD_VID $CHILD_NAME
		echo -n '.'
	done
	# We can't count ifaces right in the while cycle due to pipe.
	echo "`egrep -vc '^$|^#' $VLANTAB` ifaces created."
}

stop_vlantab()
{
	echo -n "Processing $VLANTAB: "
	[ -s `profiled_filename $VLANTAB` ] || {
		echo empty.
		return
	}
	local HOST_IFACE CHILD_VID CHILD_NAME
	local -i -x VLANCNT=0
	SourceIfNotEmpty `profiled_filename $IFACEDIR/default/options-vlan`
	egrep -v '^$|^#' $VLANTAB | while read HOST_IFACE CHILD_VID CHILD_NAME; do
		shutdown_vlan_iface $HOST_IFACE $CHILD_VID $CHILD_NAME
		echo -n '.'
	done
	# See start_vlantab().
	echo "`egrep -vc '^$|^#' $VLANTAB` ifaces deleted."
}

iface_is_up()
{
	local NAME=${1:?missing 1st argument to $FUNCNAME}
	$IP link show dev $NAME 2>/dev/null | awk '{print $3}' | grep -qs '[<,]UP[,>]'
	return $?
}

try_rmmod()
{
	local MODNAME=${1:?missing 1st argument to $FUNCNAME}
	$LSMOD | egrep -qs "^$MODNAME +[0-9]+ +0 " && rmmod $MODNAME
}

# Look if iface name will change after ifrename call.
get_mapped_ifname()
{
	if [ -s "`profiled_filename $IFTAB`" ]; then
		[ -x $IFRENAME ] || {
			print_error "$IFRENAME is unavailable, but `profiled_filename $IFTAB` exists"
			exit 1
		}
		NEW_NAME=`$IFRENAME -c `profiled_filename $IFTAB` ${1:+-i $1} -f 2>/dev/null | head -1`
		[ $? = 0 -a -n "$NEW_NAME" ] && echo $NEW_NAME
	fi
}

profiled_filename()
{
	local BASE=${1:?missing 1st arg to $FUNCNAME}
	local CAND=$BASE${PROFILE:+.$PROFILE}
	[ -e $CAND ] && echo $CAND || echo $BASE
}

# TODO: check once again order of overrides
init_profile()
{
	if [ -n "$1" ]; then
		PROFILE="$1"
	elif [ -s "$MYIFACEDIR/selectprofile" -a -x "$MYIFACEDIR/selectprofile" ]; then
		PROFILE=`$MYIFACEDIR/selectprofile | head -1 | awk '{print $1}'`
	elif [ -z "$PROFILE" ]; then
		if [ -s "$PROFILE_FILE" -a -r "$PROFILE_FILE" ]; then
			PROFILE=`egrep -v '^$|^#' "$PROFILE_FILE" | head -1 | awk '{print $1}'`
		elif [ -r "$PROC_CMDLINE" ]; then
			# try to fetch profile name from kernel options
			PROFILE=`cat "$PROC_CMDLINE" | sed 's/  / /g' | \
			sed 's/ /\n/g' | egrep '^netprof=' | awk -F= '{print $2}'`
		fi
	fi
}

# taken directly from net-scripts
check_eth_link ()
{
	local NAME=${1:?missing 1st argument to $FUNCNAME}
	local res
	[ -x $IFPLUGSTATUS ] || {
		print_error "$IFPLUGSTATUS does not exist or is not executable. Try installing ifplugd RPM."
		return 1
	}
	$IFPLUGSTATUS -q $NAME
	res=$?
	[ "$res" = 3 ] && return 1
	return 0
}

