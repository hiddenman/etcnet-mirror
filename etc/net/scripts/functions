#!/bin/bash

. /etc/init.d/functions
# defaults
SourceIfNotEmpty /etc/net/options

supported_type()
{
	local TYPE=${1:?missing 1st arg to $FUNCNAME}
	[ -x $SCRIPTDIR/create-$TYPE -o -x $SCRIPTDIR/destroy-$TYPE ] && return 0
	return 1
}

# translate iface name into corresponding type
name2type()
{
	local NAME=${1:?missing 1st arg to $FUNCNAME}
	local CAND=${NAME//[0-9]*/}
	supported_type $CAND && echo $CAND
}

type2group()
{
	local TYPE=${1:?missing 1st arg to $FUNCNAME}
	case "$TYPE" in
		lo|dummy)
			echo '0'
		;;
		eth|plip|usb)
			echo '1'
		;;
		vlan|bond|bri|teql)
			echo '2'
		;;
		iptun|ipsectun)
			echo '3'
		;;
		ppp|ippp|pptp)
			echo '4'
		;;
	esac
}

group2name()
{
	local G=${1:?missing 1st arg to $FUNCNAME}
	case "$G" in
		0)
			echo 'virtual'
		;;
		1)
			echo 'realphys'
		;;
		2)
			echo 'hostedphys'
		;;
		3)
			echo 'indeplog'
		;;
		4)
			echo 'deplog'
		;;
	esac
}

# read options hierarchy
pickup_options()
{
	# to determine iface type we must read it's config, but
	# we should read global config and type config first.
	# A workaround here.
	SourceIfNotEmpty `profiled_filename $MYIFACEDIR/options`
	is_yes "$DISABLED" && return
	[ -z "$TYPE" ] && TYPE=`name2type $NAME`
	[ -z "$TYPE" ] && {
		print_error "No TYPE is specified for iface '$NAME' and can't guess automatically. Please fix."
		return 1
	}
	if ! supported_type $TYPE; then
		print_error "iface type '$TYPE' is not supported"
	fi
	# source default options
	SourceIfNotEmpty `profiled_filename $IFACEDIR/default/options`
	# then source default options for our iface type
	SourceIfNotEmpty `profiled_filename $IFACEDIR/default/options-$TYPE`
	# and finally source iface options
	SourceIfNotEmpty `profiled_filename $MYIFACEDIR/options`
}

print_error()
{
	echo "ERROR: $0: $@" > /dev/stderr
	# don't hang if logger hangs
	logger -p daemon.info -t "ERROR: $0: $@" &
}

if is_yes "$VERBOSE"; then
	print_message()
	{
		echo "$@"
	}
else
	print_message() { return; }
fi

print_progress()
{
	local SYMBOL=${1:-.}
	is_yes "$PROGRESS" && print_message -n "$SYMBOL"
}

# get VLAN iface name by host iface and VLAN ID
get_vlan_ifname()
{
	local HOSTIFACE=${1:?missing 1st arg to $FUNCNAME}
	local VID=${2:?missing 2nd arg to $FUNCNAME}
	grep "|\ *$VID\ *|\ *$HOSTIFACE" /proc/net/vlan/config | awk '{print $1}'
}

# create VLAN iface <parent iface> <VLAN ID> [name]
setup_vlan_iface()
{
	local HOST_IFACE=${1:?missing 1st arg to $FUNCNAME}
	local VID=${2:?missing 2nd arg to $FUNCNAME}
	local NAME=$3
	local ADDRESS=$4
	[ -x "${VCONFIG:-$DEFAULT_VCONFIG}" ] || {
		print_error "$VCONFIG does not exist or is not executable. Try installing vlan-utils24 RPM."
		exit 2
	}
	${VCONFIG:-$DEFAULT_VCONFIG} set_name_type ${NAMETYPE:-$DEFAULT_VLAN_NAMETYPE} >/dev/null 2>&1
	${VCONFIG:-$DEFAULT_VCONFIG} add $HOST_IFACE $VID >/dev/null 2>&1
	local REALNAME=`get_vlan_ifname $HOST_IFACE $VID`
	if [ -z "$NAME" -o "$NAME" = "AUTO" ]; then
		NAME=$REALNAME
	else
		$IP link set $REALNAME name $NAME
	fi
	[ -n "$ADDRESS" ] && $IP address add $ADDRESS dev $NAME
	$IP link set dev $NAME up
}

shutdown_vlan_iface()
{
	local VCONFIG
	[ -x "${VCONFIG:-$DEFAULT_VCONFIG}" ] || {
		print_error "$VCONFIG does not exist or is not executable. Try installing vlan-utils24 RPM."
		exit 1
	}
	local HOST_IFACE=${1:?missing 1st arg to $FUNCNAME}
	local VID=${2:?missing 2nd arg to $FUNCNAME}
	local NAME=`get_vlan_ifname $HOST_IFACE $VID`
	$IP address flush dev $NAME >/dev/null 2>&1
	${VCONFIG:-$DEFAULT_VCONFIG} rem $NAME >/dev/null 2>&1
}

start_vlantab()
{
	local PROFILED_VLANTAB=`profiled_filename $VLANTAB`
	print_message -n "Processing $PROFILED_VLANTAB: "
	[ -s $PROFILED_VLANTAB ] || {
		print_message empty.
		return
	}
	$MODPROBE 8021q || {
		print_error "8021q kernel module not found"
		exit 2
	}
	local HOST_IFACE CHILD_VID CHILD_NAME
	SourceIfNotEmpty `profiled_filename $IFACEDIR/default/options-vlan`
	egrep -v '^$|^#' $PROFILED_VLANTAB | while read HOST_IFACE CHILD_VID CHILD_NAME; do
		iface_is_up "$HOST_IFACE" && setup_vlan_iface $HOST_IFACE $CHILD_VID $CHILD_NAME
		print_progress
	done
	# We can't count ifaces right in the while cycle due to pipe causing new process
	print_message "`egrep -vc '^$|^#' $PROFILED_VLANTAB` lines processed."
}

stop_vlantab()
{
	local PROFILED_VLANTAB=`profiled_filename $VLANTAB`
	print_message -n "Processing $PROFILED_VLANTAB: "
	[ -s $PROFILED_VLANTAB ] || {
		print_message empty.
		return
	}
	local HOST_IFACE CHILD_VID CHILD_NAME
	SourceIfNotEmpty `profiled_filename $IFACEDIR/default/options-vlan`
	egrep -v '^$|^#' $PROFILED_VLANTAB | while read HOST_IFACE CHILD_VID CHILD_NAME; do
		shutdown_vlan_iface $HOST_IFACE $CHILD_VID $CHILD_NAME
		print_progress
	done
	# See start_vlantab().
	print_message "`egrep -vc '^$|^#' $PROFILED_VLANTAB` lines processed."
}

iface_is_up()
{
	local NAME=${1:?missing 1st argument to $FUNCNAME}
	$IP link show dev $NAME 2>/dev/null | awk '{print $3}' | grep -qs '[<,]UP[,>]'
	return $?
}

try_rmmod()
{
	local MODNAME=${1:?missing 1st argument to $FUNCNAME}
	# Note: usage counter is treated in a different way by 2.6 kernels.
	# This may cause bugs :(
	$LSMOD | egrep -qs "^$MODNAME +[0-9]+ +0 " && rmmod $MODNAME
}

# Look if iface name will change after ifrename call.
get_mapped_ifname()
{
	local OLDNAME=${1:?missing 1st argument to $FUNCNAME}
	local PROF_IFTAB=`profiled_filename $IFTAB`
	if [ -s "$PROF_IFTAB" ]; then
		[ -x $IFRENAME ] || {
			print_error "$IFRENAME is unavailable, but $PROF_IFTAB exists"
			exit 1
		}
		NEW_NAME=`$IFRENAME -c $PROF_IFTAB -i $OLDNAME -D 2>/dev/null | head -1 | awk '{print $7}' | sed 's/.$//'`
		[ $? = 0 -a -n "$NEW_NAME" ] && echo $NEW_NAME
	fi
}

profiled_filename()
{
	local BASE=${1:?missing 1st arg to $FUNCNAME}
	local CAND=$BASE${PROFILE:+.$PROFILE}
	[ -e $CAND ] && echo $CAND || echo $BASE
}

# TODO: check once again order of overrides
init_profile()
{
	if [ -n "$1" ]; then
		PROFILE="$1"
	elif [ -n "$MYIFACEDIR" -a -s "$MYIFACEDIR/selectprofile" -a -x "$MYIFACEDIR/selectprofile" ]; then
		PROFILE=`$MYIFACEDIR/selectprofile $0| head -1 | awk '{print $1}'`
	elif [ -z "$PROFILE" ]; then
		if [ -s "$PROFILE_FILE" -a -r "$PROFILE_FILE" ]; then
			PROFILE=`egrep -v '^$|^#' "$PROFILE_FILE" | head -1 | awk '{print $1}'`
		elif [ -r "$PROC_CMDLINE" ]; then
			# try to fetch profile name from kernel options
			PROFILE=`cat "$PROC_CMDLINE" | sed 's/  / /g' | \
			sed 's/ /\n/g' | egrep '^netprof=' | awk -F= '{print $2}'`
		fi
	fi
}

# taken directly from net-scripts
check_eth_link ()
{
	local NAME=${1:?missing 1st argument to $FUNCNAME}
	local res
	[ -x $IFPLUGSTATUS ] || {
		print_error "$IFPLUGSTATUS does not exist or is not executable. Try installing ifplugd RPM."
		return 1
	}
	$IFPLUGSTATUS -q $NAME
	res=$?
	[ "$res" = 3 ] && return 1
	return 0
}

# iterator
foreach_child ()
{
	local WHAT=${1:?missing 1st argument to $FUNCNAME}
	local CHILDREN=`$SCRIPTDIR/childfinder $NAME`
	local ret=0
	for child in $CHILDREN; do
		$SCRIPTDIR/$WHAT $child || ret=$((ret+1))
	done
	return $ret
}

# get down all dependant ifaces
ifdown_children ()
{
	foreach_child ifdown
}

# same for ifdown
ifup_children ()
{
	foreach_child ifup
}

# check if parent iface(s) (REQUIRES=) is up and ifup if needed
ifup_parents ()
{
	local parent ret=0
	for parent in $REQUIRES; do
		if ! iface_is_up $parent; then
			$SCRIPTDIR/ifup $parent || {
				ret=$?
				break
			}
		fi
	done
	return $ret
}

ifdown_parents ()
{
	local parent ret=0
	for parent in $REQUIRES; do
		if iface_is_up $parent; then
			$SCRIPTDIR/ifdown $parent || {
				ret=$?
				break
			}
		fi
	done
	return $ret
}

iface_exists ()
{
	local NAME=${1:?missing 1st argument to $FUNCNAME}
	$IP li sh dev $NAME >/dev/null 2>&1
	return $?
}

seen_iface ()
{
	local needle=${1:?missing 1st arg to $FUNCNAME}
	for cand in $SEEN_IFACES; do
		[ "$cand" = "$needle" ] && return 0
	done
	return 1
}

add_seen_iface ()
{
	local newname=${1:?missing 1st arg to $FUNCNAME}
	if [ -z "$SEEN_IFACES" ]; then
		SEEN_IFACES=$newname
	else
		SEEN_IFACES="$SEEN_IFACES $newname"
	fi
}

# Universal configuration processor. Automatically does profiling,
# comments filtering and progress reporting.
xargise_file()
{
	local BASEFILE="${1:?missing 1st arg to $FUNCNAME}"
	local PROCESSOR="${2:?missing 2nd arg to $FUNCNAME}"
	local REALFILE=`profiled_filename $BASEFILE`
	if [ -s $REALFILE ]; then
		egrep -v '^$|^#' $REALFILE | xargs --max-lines=1 $PROCESSOR && print_progress
	fi
}

# see ifaces/default/options-eth
wait_for_macaddr()
{
	local TARGET="${1:?missing 1st arg to $FUNCNAME}"
	[ -z "$MACADDR_WAITTIME" ] && return
	[ "$MACADDR_WAITTIME" -gt "0" -a "$MACADDR_WAITTIME" -le "1000" ] || {
		print_error "MACADDR_WAITTIME exceeds 1000 (100 seconds)"
		return
	}
	local i
	for i in `seq 1 $MACADDR_WAITTIME`; do
		if $IP li sh dev $TARGET 2>/dev/null | fgrep -q 'link/ether 00:00:00:00:00:00'; then
			usleep 100000
		else
			break
		fi
	done
}

process_sysctl_conf()
{
	local SRCFILE=${1:?missing 1st arg to $FUNCNAME}
	local NAME=$2
	local ONELINE
	local VARPREFIX
	[ -s $SRCFILE ] || return 0
	egrep -v '^$|^#' $SRCFILE | sed "s/ //g" | while read ONELINE; do
		local VARNAME=`echo $ONELINE | awk -F= '{print $1}'`
		local VARVALUE=`echo $ONELINE | awk -F= '{print $2}'`
		# If variable name contains dot(s), we use it as is. Otherwise
		# we append interface prefix.
		if echo $VARNAME | fgrep -vq .; then
			[ -z $NAME ] && {
				print_error "Can't autocomplete sysctl variable name '$VARNAME' in file '$SRCFILE'. Please fix"
				return 1
			}
			# try to guess prefix from variable name
			# There should be a better way to build this case block...
			case $VARNAME in
				force_igmp_version|disable_policy|disable_xfrm|arp_ignore|arp_announce)
					VARPREFIX="net.ipv4.conf.$NAME."
				;;
				arp_filter|tag|log_martians|bootp_relay|medium_id|proxy_arp)
					VARPREFIX="net.ipv4.conf.$NAME."
				;;
				accept_source_route|send_redirects|rp_filter|shared_media)
					VARPREFIX="net.ipv4.conf.$NAME."
				;;
				secure_redirects|accept_redirects|mc_forwarding|forwarding)
					VARPREFIX="net.ipv4.conf.$NAME."
				;;
				locktime|proxy_delay|anycast_delay|proxy_qlen|unres_qlen)
					VARPREFIX="net.ipv4.neigh.$NAME."
				;;
				gc_stale_time|delay_first_probe_time|base_reachable_time)
					VARPREFIX="net.ipv4.neigh.$NAME."
				;;
				retrans_time|app_solicit|ucast_solicit|mcast_solicit)
					VARPREFIX="net.ipv4.neigh.$NAME."
				;;
				*)
					print_error "Can't autocomplete sysctl variable name '$VARNAME' in file '$SRCFILE'. Please fix"
					return 1
			esac
		fi
		$SYSCTL -q -w $VARPREFIX$VARNAME=$VARVALUE
	done
	return 0
}

stop_dhcp_client()
{
	local PIDFILE=/var/run/dhcpcd-$NAME.pid
	[ -s $PIDFILE ] && kill -SIGHUP `cat $PIDFILE`
	# There probably should be a delay/wait loop here, dhcpcd doesn't die fast.
	sleep ${DHCPCD_GRACE_TIME:-0}
}
